// unsolved
// I've implemented Dikshtra's algotithm, still it doesn't work. I don't know why. 
// My ans 452.42 isn't accepted as ans which is right by Dikstra's
/*
	To check I'd implement on 
    	float A[5][5]={0, 15, 4, 2, 8,
				   15, 0, 13, 9, 7,
				   4, 13, 0, 5, 7,
				   2, 9, 5, 0, 5,
				   8, 7, 7, 5, 0};
                   
	For which the shortest path is 7.00. and my code works correctly. Either there is scoemthing wrong with the question or I have to apply a different appreach
*/

/************************************************************************************************/
/*					PROBLEM INSTRUCTIONS					*/
/************************************************************************************************/

/*
1. Salma is at the airport and you are to reach there as soon as possible to
be able to reach her in time.
2. The array 'paths' contains the distances. A[x][y] gives the distance from
location x to location y.
3. You are at location 0 and are supposed to reach location 19 along the shortest path.
4. The shortest_path function is supposed to calculate the minimum distance along
any path from location 0 to location 19 along any path.
5. The function returns a float value shortest_distance (already declared),
which is printed in the main function.
*/

#include <iostream>
#include <cfloat>
#include <queue>
#include <algorithm>
#include <vector>
#include <iomanip>
using namespace std;

float shortest_path(float paths[20][20]);
int main()
{
	float distance;
	float A[20][20]={0.00,840.19,394.38,783.10,798.44,911.65,197.55,335.22,768.23,277.77,553.97,477.40,628.87,364.78,513.40,952.23,916.20,635.71,717.30,941.60,606.97,0.00,16.30,242.89,137.23,804.18,156.68,400.94,129.79,108.81,998.92,218.26,512.93,839.11,612.64,296.03,637.55,524.29,493.58,972.78,292.52,771.36,0.00,526.74,769.91,400.23,891.53,283.31,352.46,807.72,919.03,69.76,949.33,526.00,86.06,192.21,663.23,890.23,348.89,64.17,20.02,457.70,63.10,0.00,238.28,970.63,902.21,850.92,266.67,539.76,375.21,760.25,512.54,667.72,531.61,39.28,437.64,931.84,930.81,720.95,284.29,738.53,639.98,354.05,0.00,687.86,165.97,440.10,880.08,829.20,330.34,228.97,893.37,350.36,686.67,956.47,588.64,657.30,858.68,439.56,923.97,398.44,814.77,684.22,910.97,0.00,482.49,215.82,950.25,920.13,147.66,881.06,641.08,431.95,619.60,281.06,786.00,307.46,447.03,226.11,187.53,276.23,556.44,416.50,169.61,906.80,0.00,103.17,126.08,495.44,760.48,984.75,935.00,684.45,383.19,749.77,368.66,294.16,232.26,584.49,244.41,152.39,732.15,125.47,793.47,164.10,745.07,0.00,74.53,950.10,52.53,521.56,176.21,240.06,797.80,732.65,656.56,967.41,639.46,759.73,93.48,134.90,520.21,78.23,69.91,204.66,461.42,819.68,0.00,573.32,755.58,51.94,157.81,999.99,204.33,889.96,125.47,997.80,54.06,870.54,72.33,4.16,923.07,593.89,180.37,163.13,391.69,913.03,819.70,0.00,359.10,552.49,579.43,452.58,687.39,99.64,530.81,757.29,304.30,992.23,576.97,877.61,747.81,628.91,35.42,747.80,833.24,925.38,873.27,831.04,0.00,979.43,743.81,903.37,983.60,666.88,497.26,163.97,830.01,888.95,76.99,649.71,248.04,629.48,229.14,700.62,316.87,328.78,231.43,74.16,633.07,0.00,223.66,651.13,510.69,971.47,280.04,546.11,719.27,113.28,471.48,592.54,944.32,450.92,336.35,847.68,434.51,3.23,344.94,598.48,833.24,233.89,0.00,675.48,482.95,481.94,304.96,712.09,182.56,621.82,40.86,413.98,695.98,673.94,637.64,347.12,184.62,609.11,627.16,730.73,328.37,740.44,202.21,0.00,920.91,684.76,653.13,257.27,532.44,87.64,260.50,877.38,686.12,93.74,111.28,361.60,576.69,593.21,666.56,288.78,775.77,288.38,329.64,189.75,0.00,984.36,3.58,827.39,331.48,188.20,436.50,958.64,918.93,764.87,699.08,121.14,685.79,383.83,774.27,943.05,916.27,861.92,203.55,793.66,548.04,0.00,297.29,904.93,909.64,873.98,498.14,576.20,162.76,273.91,864.58,492.40,463.66,848.94,495.98,291.05,180.42,684.18,727.55,139.06,603.11,492.42,0.00,838.13,724.25,178.21,221.97,498.53,121.26,138.24,360.44,324.81,931.90,908.48,622.10,836.83,818.13,496.07,334.97,394.33,658.83,608.88,258.91,0.00,151.23,72.55,107.85,647.21,363.60,288.27,331.39,91.15,427.33,934.49,583.57,265.46,658.75,761.78,487.43,157.27,883.04,625.67,517.71,207.84,0.00,557.56,426.20,829.94,394.39,244.33,326.01,729.36,638.65,984.84,338.24,897.56,136.07,410.79,5.41,783.28,774.39,293.68,114.67,865.53,721.01,0.00};
	distance=shortest_path(A);
	cout<<fixed;
	cout.precision(2);
	cout<<distance << endl;
	return 0;
}

float shortest_path(float paths[20][20])
{
	float shortest_distance = 0.0;
	
	vector< bool > isVisited(20, false);
	vector< float > minDistance(20, FLT_MAX);
	queue<int> q;
		
	// initialize queue
	q.push(0);		
	minDistance[0] = 0;
	
	while(!q.empty())
	{
		int pos = q.front();
		q.pop();
		isVisited[pos] = true;
		//cout << "visited" << pos << endl;

		for(int i=0; i<20; i++)
		{
			if(i==pos)		// distance from i to i is 0;
				continue;
			float dist = minDistance[pos]+paths[pos][i];	// get the min distance from start to that point
			if(dist < minDistance[i])
				minDistance[i] = dist;
			if(isVisited[i] == false)		// if not already visited
			q.push(i);				// enqueue only those which are unvisited yet
		}

	}

	shortest_distance = minDistance[19];
	return shortest_distance;
}
